"use strict";define([cardGame.gamePath+"js/models/PlayerInGame.js",cardGame.gamePath+"js/models/Card.js",cardGame.gamePath+"js/models/CardOnBoard.js"],function(o,e,r){return class t{constructor(o,e){if(o<=0)throw new RangeError("The number of rows should be greater than 0");if(e<=0)throw new RangeError("The number of rows should be greater than 0");this.rows=o,this.cols=e,this.board=[];for(let o=0;o<this.rows;o++){this.board[o]=[];for(let e=0;e<this.cols;e++)this.board[o][e]=void 0}}static getCardPositions(){return{TOP:0,TOP_RIGHT:1,RIGHT:2,BOTTOM_RIGHT:3,BOTTOM:4,BOTTOM_LEFT:5,LEFT:6,TOP_LEFT:7}}getRows(){return this.rows}getCols(){return this.cols}playCardOnBoard(t,s,a,i){if("object"!=typeof t||!(t instanceof e))throw new TypeError("Expected Card type");if("object"!=typeof s||!(s instanceof o))throw new TypeError("Expected PlayerInGame type");if(a<0||a>this.rows)throw new RangeError("The row should be between 0 and "+this.rows);if(i<0||i>this.cols)throw new RangeError("The column should be between 0 and "+this.cols);void 0!==this.board[a][i]&&logger.warning("There is already a card on the board at this position"),this.board[a][i]=new r(t,s)}getCardOnBoard(o,e){if(o<0||o>this.rows)logger.warning("The row should be between 0 and "+this.rows+" but [row: "+o+"] found");else{if(!(e<0||e>this.cols))return this.board[o][e];logger.warning("The column should be between 0 and "+this.cols+" but [col: "+e+"] found")}}getCardAbove(o,e){return o-1>=0?this.board[o-1][e]:void 0}getCardOnTheRight(o,e){return e+1<this.cols?this.board[o][e+1]:void 0}getCardBelow(o,e){return o+1<this.rows?this.board[o+1][e]:void 0}getCardOnTheLeft(o,e){return e-1>=0?this.board[o][e-1]:void 0}getCardCoordinate(o){"object"==typeof o&&o instanceof r||logger.warning("Expected CardOnBoard type");for(let e=0;e<this.rows;e++)for(let r=0;r<this.cols;r++)if(this.board[e][r]===o)return{row:e,col:r}}getRelativePositionOf(o,e){"object"==typeof o&&o instanceof r||logger.warning("Expected CardOnBoard type"),"object"==typeof e&&o instanceof r||logger.warning("Expected CardOnBoard type but");let s=this.getCardCoordinate(o),a=this.getCardCoordinate(e);if(void 0===s||void 0===a)return void logger.warning("[card1: "+o.getCard().getName()+"] and/or [card2: "+e.getCard().getName()+"] are not on the board");let i;return s.col===a.col&&s.row<a.row?i=t.getCardPositions().TOP:s.col>a.col&&s.row<a.row?i=t.getCardPositions().TOP_RIGHT:s.col>a.col&&s.row===a.row?i=t.getCardPositions().RIGHT:s.col===a.col&&s.row>a.row?i=t.getCardPositions().BOTTOM:s.col<a.col&&s.row>a.row?i=t.getCardPositions().BOTTOM_LEFT:s.col<a.col&&s.row===a.row?i=t.getCardPositions().LEFT:s.col<a.col&&s.row<a.row&&(i=t.getCardPositions().TOP_LEFT),logger.debug("[card1: "+o.getCard().getName()+"; row: "+s.row+"; col: "+s.col+"]'s relative position to [card2: "+e.getCard().getName()+"; row: "+a.row+"; col: "+a.col+"] is "+Object.keys(t.getCardPositions())[i]),i}getPlayerScore(e){"object"==typeof e&&e instanceof o||logger.warning("Expected PlayerInGame type");let r=0;for(let o=0;o<this.rows;o++)for(let t=0;t<this.cols;t++)"object"==typeof this.board[o][t]&&this.board[o][t].getOwner()===e&&r++;return r}isComplete(){for(let o=0;o<this.rows;o++)for(let e=0;e<this.cols;e++)if(void 0===this.board[o][e])return!1;return!0}getEmptyCases(){let o=[];for(let e=this.rows-1;e>=0;e--)for(let r=this.cols-1;r>=0;r--)void 0===this.board[e][r]&&o.push([e,r]);return o}}});